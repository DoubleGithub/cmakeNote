# 3 构建细则和使用要求(build specification & usage requirement)
三个指令"target_include_directories()","target_compile_definitions()"和"target_compile_optins()"指出了构建的详细依赖关系。

> 1，target_include_directories 指出目标所依赖的头文件目录，其用于修改INCLUDE_DIRECTORIES，和INTERFACE_INCLUDE_DIRECTORIES变量。  
2，target_compile_definitions 指出编译目标期间需要的宏定义。其修改变量COMPILE_DEFINITINON和INTERFACE_COMPILE_DEFINITIONS.  
3，target_compile_optins 指出编译目标依赖的选项，其修改变量COMPILE_OPTIONS和INTERFACE_COMPILE_OPTIONS.


上面的每条指令都有PUBLIC, PRIVATE, INTERFACE三种模式。每条指令可以使用多种模式进行修饰。（变量的类型见下面的“transitive usage requirement”）

> PRIVATE: 修饰target属性中的非interface类型变量。  
INTERFACE: 修饰target属性中的interface类型变量。  
PUBLIC:两种类型变量都修饰。

```
target_compile_definitions (archive
  PRIVATE BUIDL_WITH_LZMA
  INTERFACE USING_ARCHIVE_LIB
  )
```

需要注意，尤其对于COMPILE_OPTIONS和COMPILE_DEFINITIONS这种，三种作用域的修饰并不是为方便向下传递变量。这些属性定义一定是在本层中真正能使用到。具体参见cmake-package章节中的"creating relocate package"，进一步了解作用域。

## 1 目标属性 (target property)
INCLUDE_DIRECTORIES, COMPILE_DEFINITIONS,COMPILE_OPTIONS用于控制编译目标。下面进行简单介绍。

> 1，INCLUDE_DIRECTORIES 变量中的路径对应于，使用编译选项：-I或者-isystem前缀。其值按照出现顺序进行排列。  
2，COMPILE_DEFINITIONS中的条目，对应于以-D或者/D开头的宏定义，注意，宏定义没有顺序性。SHARED或者MODULE的库类型，使用属性DEFINE_SYMBOL来定义宏。  
3，COMPILE_OPTIONS转义给shell，并按照出现顺序赋值给相应变量。许多编译选项都会单独处理，比如POSITION_INDEPENDENT_CODE。

INTERFACE_INCLUDE_DIRECTORIES, INTERFACE_COMPILE_DEFINITIONS, INTERFACE_COMPILE_OPTIONS内容经过usage requirement修饰，其规定了用户如何在编译和连接中使用。对于binary目标，每个INTERFACE属性的内容在target_link_libraries中都会被用到。如下所示：

```
set (src archive.cpp app.cpp)
if (LZMA_FOUND)
  list (APPEND src lzma.cpp)
endif()

add_library (archive SHARED ${src})

if (LZMA_FOUND) # 库archive使用宏定义-DBUILDING_WITH_LZMA编译
  target_compile_definitions (archive PRIVATE DBUILDING_WITH_LZMA)
endif()

target_compile_definitions (archive INTERFACE USING_ARCHIVE_LIB)
add_executable (consumer)
# 连接archive，并使用期usage-requirement，即consumer程序将使用-DUSING_ARCHIVE_LIB进行编译
target_link_libraries (consumer archive)
```

编译时，源文件目录和对应的构建目录路径，经常会赋值给INCLUDE_DIRECTORIES变量，为了方便，CMAKE_INCLUDE_CURRENT_DIR直接将所有目标的两种目录，赋值给INCLUDE_DIRECTORIES。

CMAKE_INCLUDE_CURRENT_DIR_IN_INTERFACE会将所有的目标，对应的目录添加到INTERFACE_INCLUDE_DIRECTORIES中。这样就能在连接过程target_link_libraries中，方便使用各个目录中的文件。


## 2 目标传递使用要求 (transitive usage requirement)

目标的依赖属性可以进行传递。指令“target_link_libraries”使用PUBLIC, PRIVATE, INTERFACE三种关键字来控制传递。

下面指令中，archiveExtras私有依赖于serialization，因此，consumer就不能使用serialization定义的宏USING_SERIALIZATION_LIBS。

```
add_library (archive archive.cpp)
target_compile_definitions (archive INTERFACE USING_ARCHIVE_LIB)

add_library (serialization serialization.cpp)
target_compile_definitions (serialization INTERFACE USING_SERIALIZATION_LIBS)

# archiveExtras传入宏定义编译选项：-DUSING_ARCHIVE_LIB和-DUSING_SERIALIZATION_LIB
add_library (archiveExtras extras.cpp)
target_link_libraries (archiveExtras PUBLIC archive)
target_link_libraries (archiveExtras PRIVATE serialization) #private禁止向上传递

# consumer只使用编译选项：-DUSING_ARCHIVE_LIB
add_executable (consumer consumer.cpp)
target_link_libraries (consumer archiveExtras)
```



```
target_link_libraries (archiveExtras
  PUBLIC archive
  PRIVATE serialization
  )
```
未翻译

## 3 兼容接口属性 (compatible interface requirement)
## 4 调试属性 (property origin debugging)
## 5 使用生成语句的构建细则 (build-specification and generator-expression)
#### 1 目录包含和使用要求 (include-directories and usage-requirement)
## 6 链接库和生成语句 (link-libraries and generator-expression)
## 7 输出文件 (output-files)
## 8 目录范围命令 (directory-scoped commands)
