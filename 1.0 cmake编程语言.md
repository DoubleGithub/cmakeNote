# 0 序言
cmake是一种脚本语言，我们使用CMakeLists.txt，或者扩展名是.cmake文件作为输入文件——以下称为源文件、或指令文件，让cmake程序解析里面的命令，得到相应地输出

# 1 结构（organization）
cmake源文件按照使用途径，被组织成如下形式：

1. 目录：CMakeLists.txt  
2. 脚本：“.cmake”文件
3. 模块：“.cmake”文件

### 1 目录（Directory）
cmake在处理源代码树时（因为文件和目录的结构类似于树形结构，所以叫做源代码树，实际就是工程目录），以最顶层目录的CMakeLists.txt为切入点，首先处理这个文件。

若希望继续处理子目录，读取子目录的CMakeLists.txt，则在当前的CMakeLists.txt中继续添加子目录位置。

cmake程序会在构建(build)目录树下，创建于源文件完全对应的目录结构。若目录结构如下.src目录下有chinese和english目录，则构建目录build下，也会有chinese和english目录。

```
/firstTest
  |-----/src
      |----/chinese
      |----/english
  |-----build （下面的chinese和english使用cmake创建出来的）
      |----/chinese  
      |----/english
```


### 2 脚本（script）

cmake命令行程序，通过-P选项，可以传入以".cmake"为扩展名的脚本文件，进入脚本模式(script mode)。运行脚本文件不会创建“构建系统(build-system)”——其不允许cmake生成目标文件等操作。

### 3 模块（module)

CMakeLists.txt或者.cmake脚本可以使用include()指令来加载<module>.cmake文件。用户也可以自定义模块，通过CMAKE_MODULE_PATH变量来指定模块的位置。

# 2 语法(syntax)

### 1 编码(encoding)
换行符可以使\\n，也可以是\\r\\n两种，这两个都会被转换成\\n。

### 2 源代码文件(source file)
cmake的指令文件由若干指令构成，每条指令由换行符、空格、tab、注释等分隔。如下为命令描述。任何不在“指令参数(command-arguments)”或者"方括号注释(bracket-comment)"中的指令都可以“行注释(line-comment)”结尾。

（注意，下面语法描述采用递归和正则表达式的方式进行描述。虽然规范，但多少有一点晦涩）


```
file        ::= fileElement*
fileElement ::= command-invocation lineEnd |
                (bracket-comment | space)* lineEnd
lineEnd     ::= line-comment? newLine
space       ::= <match '[ \t]+'>
newLine     ::= <match '\n'>
```

### 3 指令(command-invocation)
一条指令后面，参数用圆括号包围。参数之间用空格隔开。如下定义形式：

```
command-invocation  ::= space* identifier space* '('arguments')'
identifier          ::= <match '[A-Za-z_][A-Za-z0-9_]*'>
arguments           ::= argument ? separated-arguments*
separated-arguments ::= separation+ argument? |
                        separation* '(' arguments ')'
separation          ::= space | lineEnd
```

如下面例子将创建可执行文件main，该文件依赖于main.cpp文件。
add_executable (main main.cpp)

cmake中的指令大小写不敏感，指令参数也可以用圆括号包起来，来改变运算顺序。如下所示：

```
if (FALSE AND (FALSE OR TRUE)) # 求值为FALSE
```

### 4 指令参数(command argument)
共有三种形式的指令参数。如下所示：

```
argument ::= bracket-argument | quoted-argument | unquoted-argument
```

##### 1 带方括号参数
受到Lua的long bracket syntax的启发，cmake开始使用方括号参数，但是3.0以前的版本不支持这个语法。定义语法如下。

```
bracket-argument  ::= bracket-open bracket-content bracket-close
bracket-open      ::= '[''='*''['
bracket-content   ::= <任何文本内容，切文本内容不能包含，与 bracket-open含有数量相同等号的 bracket-close>
bracket-end       ::= '[''='*']'

```

参数开头的等号数量任意，但是等号数量需要前后一致。需要注意，方括号不支持嵌套——只能有一层方括号参数。所以需要避免参数中出现，和结束方括号一样的字符串。

如果开头的方括号后面重启一行，则直接忽略。被包含的文本块内容不会被求值，即便是转义字符或变量引用，方括号参数总是按字符串原样传递给指令。

下面例子展示了转义：

```
message([=[
  the first line of the bracket argument, with bracket length is 1.
  no escape-sequece \t, or  ${variable_reference} is evaluated.
  even it contains semicolon; this is alway supposed-to-be one argument.
  the text doesn't end with that length of bracket is 0, like ]]
  it does end length is 1.
  ]=])
```

##### 2 带引号参数
我们使用双引号将参数包围。如下为语法定义：

```
quoted-argument   ::= '"' quoted-element* '"'
quoted-element    ::= <除了'\'和'"'的任意字符> |
                      escape-sequence |
                      quoted-continuation
quoted-continuation ::= '\' newLine
```

带引号参数会计算转义序列和变量引用，其会给出所有符号的准确值。比如下面例子：

```
message(”even it contains semicolon;, it is one argument.
  escape-sequece \\n and ${variable} are evaluated.
  ")
```

单个反斜线："\\"被认为是续下一行，该语法只在3.0以后的版本中支持。如下面所示：

```
message("\
  the 1st line of argument \
  the 2nd line of argument \
  ")
```

##### 3 不带引号参数
不带引的参数不包含空格、以及()#""\\等字符。除了转义字符。具体定义如下：

```
unquoted-argument     ::= unquoted-element+ | unquoted-legacy
unquoted-element      ::= <不包含空格，()#""\的字符串> |
                          escape-sequece
unquoted-legacy       ::= <见下面的注释>
```

不带引号的参数可会对转义序列、变量引用求值。

```
foreach (arg
  NoSpace
  Escaped\ Space
  This;Divides;Into;Five:Arguments
  Escaped\;Semicolon
  )
  message ("${arg}")
endforeach()

```

>unquoted-legacy:在旧版本中，不太引号的参数列表有可能含有带引号的参数，或者make风格的变量引用：$(variable)。

### 5 转义序列(escape sequence)
转义序列即“\\”后面跟着一个字符。定义如下：

```
escape-sequence     ::= escape-identifier | escape-encoded | escape-semicolon
escape-identifier   ::= '\'<match '[^A-Za-z9-0;]'>
escape-encoded      ::= '\t' | '\r' | '\n'
escape-semicolon    ::= '\;'
```

说明：
1. \\后面直接跟非字母和非数字的字符，则直接按原样显示。
2. \\r, \\t和\\n分别表示回车、制表符和换行符。
3. \\;在变量引用（下面一节）中会被解析为一个分号";"。

### 6 变量引用(variable reference)
变量引用的形式是${variable}，其在带引号的参数和不带引号的参数中被求值。若变量没有被声明，则其被赋值为空串。

变量引用可以嵌套：
>${outer_${inner_variable}_variable}

### 7 注释(comments)
注释以井号#开头，不能包含在方括号参数（bracket argument），带引号的参数，或使用转义符的不带引号的参数中。有两种注释形式：方括号注释和行注释。

##### 1 方括号注释(bracket comment)
井号#后面跟方括号，即创建注释。3.0之前版本不支持该功能。

```
bracket-comment ::= '#' bracket-argument
```

比如下面的例子：

```
#[[this is a bracket comment,
multi-lines are allowed]]

message("First argument\n"  #[[bracket comments]] "second argument\n")
```

##### 2 行注释(line comment)
井号#后面跟除了方括号意外的字符，即为行注释。注释到行末结束。语法定义如下：

```
line-comment ::= '#' <任何不以方括号开头的，且不换行的文本>
```
```
# this is a line comment
message ("first argument\n" # this is a line comment)
        "second argument\n" ) # this is a line comment
```

# 3 控制结构(control stucture)
### 1 条件语句块(conditional block)
if(), elseif(), else(), endif()用于进行条件控制
### 2 循环(loop)
foreach()/endforeach(), while()/endwhile()用于执行循环语句。break()命令终止循环，continue()终止当前循环，并进入下一次循环。
### 3 指令定义(command definition)
macro()/endmacro()和function()/endfunction()包裹用于后面再次调用的指令。
# 4 变量(variable)
cmake冲，变量是基本的存储单元。其值通常为字符串类型，在一些指令中，字符串会被解析成其他类型。set()和unset()可以显式创建销毁变量，一起其他命令也能修改变量值。

变量名大小写敏感，其可能包含任意字符，但建议变量名只包含数字、字母、下划线和破折号。

变量拥有动态作用域，每次set/unset都会将变量与当前的作用域绑定。具体的作用域如下：

1. Function 作用域

2. 目录作用域

3. 持久缓存(persistent cache)
# 5 列表(list)
